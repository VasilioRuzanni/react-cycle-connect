{"version":3,"file":"react-cycle-connect-extra-onionify.umd.min.js","sources":["../../src/extra/onionify/StateIsolator.tsx","../../src/extra/onionify/Collection.tsx","../../src/extra/onionify/makeFilteredListLens.ts"],"sourcesContent":["import React, { ReactNode } from \"react\";\nimport { Scope } from \"@cycle/state\";\nimport { cycleConnect } from \"react-cycle-connect\";\n\nexport interface StateIsolatorProps {\n  children: ReactNode;\n  channelName?: string;\n  lens: Scope<any, any>;\n}\n\n// TODO Assuming the use of `@cycle/state` for now,\n// make configurable, since @cycle/state itself supports that.\nconst DEFAULT_STATE_CHANNEL_NAME = \"state\";\n\nexport const StateIsolator = cycleConnect<StateIsolatorProps>({\n  isolate: (props: StateIsolatorProps) => ({\n    [props.channelName || DEFAULT_STATE_CHANNEL_NAME]: props.lens || void 0,\n    \"*\": null\n  }),\n  displayName: \"StateIsolator\"\n})();\n\nexport default StateIsolator;\n","import React, { Children, Key, ComponentType, ReactNode } from \"react\";\nimport xs, { Stream } from \"xstream\";\nimport { StateSource, Scope, Lens } from \"@cycle/state\";\nimport {\n  cycleConnect,\n  ReactPropsSource,\n  CycleConnectedProps,\n  CycleConnectOptionsProps,\n  IsolateOption,\n  IsolateOptionFn\n} from \"react-cycle-connect\";\n\n// TODO: Reconsider the implementation to make it more TypeScript-friendly\n\nexport type ItemKeyFn<TItemState> = (\n  itemState: TItemState,\n  index?: number\n) => Key;\n\nexport interface CollectionProps {\n  // TODO: Think how to make it typed easily, given\n  // the Collection component is universal, not bound\n  // to a particular item state type.\n  lens: Scope<any, any>;\n  channelName?: string;\n  itemKeyFn?: <TItemState>(itemState: TItemState, index?: number) => Key;\n  itemIsolate?: IsolateOption;\n  itemComponent?: ComponentType;\n  itemRender?: <TItemState>(\n    itemProps: TItemState,\n    itemKey?: Key,\n    index?: number\n  ) => ReactNode;\n}\n\nexport interface ViewProps<TItemState> extends CollectionProps {\n  items: TItemState[];\n}\n\nexport interface Sources {\n  props: ReactPropsSource<CollectionProps>;\n}\n\nexport interface Sinks<TItemState> {\n  props: Stream<{\n    items: TItemState[];\n  }>;\n}\n\n// TODO Assuming the use of `@cycle/state` for now,\n// make configurable, since onionify itself supports that,\n// so that it could be set globally, without the need for\n// every component to explicitly specify the `channelName`.\nconst DEFAULT_STATE_CHANNEL_NAME = \"state\";\n\nexport function defaultItemIsolate<TProps>(props: TProps) {\n  return { \"*\": null };\n}\n\n// Note: Reusing the `@cycle/state`s lens implementation almost as is.\nexport function itemLens(\n  itemKeyFn: ItemKeyFn<any>,\n  key: Key\n): Lens<any[], any> {\n  return {\n    get(arr: Array<any> | undefined): any {\n      if (typeof arr === \"undefined\") return void 0;\n      for (let i = 0, n = arr.length; i < n; ++i) {\n        if (itemKeyFn(arr[i], i) === key) {\n          return arr[i];\n        }\n      }\n      return void 0;\n    },\n\n    set(arr: Array<any> | undefined, item: any): any {\n      if (typeof arr === \"undefined\") {\n        return [item];\n      } else if (typeof item === \"undefined\") {\n        return arr.filter((s, i) => itemKeyFn(s, i) !== key);\n      }\n\n      return arr.map((s, i) => {\n        if (itemKeyFn(s, i) === key) return item;\n        return s;\n      });\n    }\n  };\n}\n\nexport function main(sources: Sources): Sinks<any> {\n  const state$ = xs.fromObservable(\n    sources.props\n      .pluck(\"channelName\")\n      .map(\n        (channelName?: string) =>\n          (sources[channelName || DEFAULT_STATE_CHANNEL_NAME] as StateSource<\n            any\n          >).stream\n      )\n      .flatten()\n  );\n\n  return {\n    props: state$.map((items: any[]) => ({ items }))\n  };\n}\n\ninterface MakeDefaultItemRenderOpts<TItemState> extends CollectionProps {\n  itemComponent: ComponentType<TItemState>;\n}\n\nfunction makeDefaultItemRender<TItemState extends CycleConnectOptionsProps>(\n  opts: MakeDefaultItemRenderOpts<TItemState>\n) {\n  const ItemComponent = opts.itemComponent;\n  const {\n    channelName = DEFAULT_STATE_CHANNEL_NAME,\n    itemKeyFn,\n    itemIsolate\n  } = opts;\n\n  return function defaultItemRender(\n    itemState: TItemState,\n    itemKey: Key,\n    index: number\n  ): ReactNode {\n    const stateScope = itemKeyFn ? itemLens(itemKeyFn, itemKey) : index;\n    const itemScope = itemIsolate || defaultItemIsolate;\n    const otherScopes =\n      typeof itemScope === \"function\"\n        ? (itemScope as IsolateOptionFn<TItemState>)(itemState)\n        : itemScope;\n\n    const itemIsolateProp =\n      typeof otherScopes === \"object\"\n        ? { ...otherScopes, [channelName]: stateScope }\n        : { \"*\": otherScopes, [channelName]: stateScope };\n\n    return (\n      <ItemComponent key={itemKey} {...itemState} isolate={itemIsolateProp} />\n    );\n  };\n}\n\nfunction render<TItemState>(props: ViewProps<TItemState>) {\n  const { items, itemKeyFn, itemRender, itemComponent } = props;\n\n  if (!items) return null;\n  if (!itemRender && !itemComponent) {\n    throw new Error(\n      'You need either \"itemRender\" or \"itemComponent\" attribute ' +\n        \"defined on a <Collection>\"\n    );\n  }\n\n  const _itemRender = itemRender || makeDefaultItemRender(props as any);\n  return items.map((itemState: TItemState, index: number) => {\n    const itemKey = itemKeyFn ? itemKeyFn(itemState, index) : index;\n    return _itemRender(itemState, itemKey, index);\n  });\n}\n\nconst cycleConnectOpts = {\n  isolate: (props: CollectionProps) => ({\n    [props.channelName || DEFAULT_STATE_CHANNEL_NAME]: props.lens || void 0,\n    \"*\": null\n  }),\n  render,\n  displayName: \"Collection\"\n};\n\nexport const Collection = cycleConnect(main, cycleConnectOpts)();\n","import { Lens } from \"@cycle/state\";\n\nexport type EqualsFn<TItemState> = (\n  item1: TItemState,\n  item2: TItemState\n) => boolean;\n\nexport function makeFilteredListLens<TState extends {}, TItemState>(\n  stateProp: string,\n  filterPredicate: (item: TItemState, state: TState) => boolean,\n  equals: string | EqualsFn<TItemState>\n): Lens<TState, TItemState[]> {\n  const mapStateProp = (state: TState) => state[stateProp] as TItemState[];\n  const equalsFn =\n    typeof equals === \"function\"\n      ? equals\n      : (item1: TItemState, item2: TItemState) =>\n          typeof item1 === \"object\" &&\n          typeof item2 === \"object\" &&\n          item1[equals] === item2[equals];\n\n  return {\n    get: (state: TState) => {\n      return mapStateProp(state).filter(item => filterPredicate(item, state));\n    },\n\n    set: (state: TState, nextFilteredItems: TItemState[]) => {\n      const arr = mapStateProp(state);\n      const prevFilteredItems = arr.filter(item =>\n        filterPredicate(item, state)\n      );\n\n      // TODO: Use spread operator once it works in TypeScript:\n      // Tracked by: https://github.com/Microsoft/TypeScript/issues/10727\n      // Fixed by (unmerged): https://github.com/Microsoft/TypeScript/pull/13288\n      return Object.assign({}, state, {\n        [stateProp]: arr\n          .map(item => nextFilteredItems.find(i => equalsFn(i, item)) || item)\n          .filter(\n            item =>\n              prevFilteredItems.some(i => equalsFn(i, item)) &&\n              nextFilteredItems.some(i => equalsFn(i, item))\n          )\n      });\n    }\n  };\n}\n"],"names":["StateIsolator","cycleConnect","isolate","props","channelName","lens","_a","displayName","DEFAULT_STATE_CHANNEL_NAME","defaultItemIsolate","*","cycleConnectOpts","render","items","itemKeyFn","itemRender","itemComponent","Error","_itemRender","opts","ItemComponent","itemIsolate","itemState","itemKey","index","stateScope","key","get","arr","i","n","length","set","item","filter","s","map","itemLens","itemScope","otherScopes","itemIsolateProp","React","makeDefaultItemRender","Collection","sources","xs","fromObservable","pluck","stream","flatten","stateProp","filterPredicate","equals","mapStateProp","state","equalsFn","item1","item2","nextFilteredItems","prevFilteredItems","Object","assign","find","some"],"mappings":"0iBAYA,IAEaA,EAAgBC,gBAC3BC,QAAS,SAACC,SAA8B,aACrCA,EAAMC,aAJwB,SAIoBD,EAAME,WAAQ,EACjEC,OAAK,QAEPC,YAAa,iBALcN,kNCuCvBO,EAA6B,QAEnC,SAAgBC,EAA2BN,GACzC,OAASO,IAAK,MA2GhB,IAAMC,GACJT,QAAS,SAACC,SAA2B,aAClCA,EAAMC,aAAeI,GAA6BL,EAAME,WAAQ,EACjEC,OAAK,QAEPM,OAvBF,SAA4BT,GAClB,IAAAU,UAAOC,cAAWC,eAAYC,kBAEtC,IAAKH,EAAO,OAAO,KACnB,IAAKE,IAAeC,EAClB,MAAM,IAAIC,MACR,uFAKJ,IAAMC,EAAcH,GA5CtB,SACEI,GAEA,IAAMC,EAAgBD,EAAKH,cAEzBV,gBAAAF,iBACAU,cACAO,gBAGF,OAAO,SACLC,EACAC,EACAC,WAEMC,EAAaX,EAnEvB,SACEA,EACAY,GAEA,OACEC,IAAA,SAAIC,GACF,QAAmB,IAARA,EACX,IAAK,IAAIC,EAAI,EAAGC,EAAIF,EAAIG,OAAQF,EAAIC,IAAKD,EACvC,GAAIf,EAAUc,EAAIC,GAAIA,KAAOH,EAC3B,OAAOE,EAAIC,IAMjBG,IAAA,SAAIJ,EAA6BK,GAC/B,YAAmB,IAARL,GACDK,QACiB,IAATA,EACTL,EAAIM,OAAO,SAACC,EAAGN,GAAM,OAAAf,EAAUqB,EAAGN,KAAOH,IAG3CE,EAAIQ,IAAI,SAACD,EAAGN,GACjB,OAAIf,EAAUqB,EAAGN,KAAOH,EAAYO,EAC7BE,MA2CoBE,CAASvB,EAAWS,GAAWC,EACxDc,EAAYjB,GAAeZ,EAC3B8B,EACiB,mBAAdD,EACFA,EAA0ChB,GAC3CgB,EAEAE,EACmB,iBAAhBD,SACEA,WAAcnC,GAAcqB,WAC/Bf,IAAK6B,IAAcnC,GAAcqB,KAEzC,OACEgB,gBAACrB,KAAcM,IAAKH,GAAaD,GAAWpB,QAASsC,MAgBvBE,CAAsBvC,GACxD,OAAOU,EAAMuB,IAAI,SAACd,EAAuBE,GACvC,IAAMD,EAAUT,EAAYA,EAAUQ,EAAWE,GAASA,EAC1D,OAAON,EAAYI,EAAWC,EAASC,MAUzCjB,YAAa,cAGFoC,EAAa1C,eAlF1B,SAAqB2C,GAanB,OACEzC,MAba0C,EAAGC,eAChBF,EAAQzC,MACL4C,MAAM,eACNX,IACC,SAAChC,GACC,OAACwC,EAAQxC,GAAeI,GAErBwC,SAENC,WAIWb,IAAI,SAACvB,GAAiB,OAAGA,aAoEEF,EAAnBV,oECpKxBiD,EACAC,EACAC,GAEA,IAAMC,EAAe,SAACC,GAAkB,OAAAA,EAAMJ,IACxCK,EACc,mBAAXH,EACHA,EACA,SAACI,EAAmBC,GAClB,MAAiB,iBAAVD,GACU,iBAAVC,GACPD,EAAMJ,KAAYK,EAAML,IAEhC,OACEzB,IAAK,SAAC2B,GACJ,OAAOD,EAAaC,GAAOpB,OAAO,SAAAD,GAAQ,OAAAkB,EAAgBlB,EAAMqB,MAGlEtB,IAAK,SAACsB,EAAeI,SACb9B,EAAMyB,EAAaC,GACnBK,EAAoB/B,EAAIM,OAAO,SAAAD,GACnC,OAAAkB,EAAgBlB,EAAMqB,KAMxB,OAAOM,OAAOC,UAAWP,UACtBJ,GAAYtB,EACVQ,IAAI,SAAAH,GAAQ,OAAAyB,EAAkBI,KAAK,SAAAjC,GAAK,OAAA0B,EAAS1B,EAAGI,MAAUA,IAC9DC,OACC,SAAAD,GACE,OAAA0B,EAAkBI,KAAK,SAAAlC,GAAK,OAAA0B,EAAS1B,EAAGI,MACxCyB,EAAkBK,KAAK,SAAAlC,GAAK,OAAA0B,EAAS1B,EAAGI"}