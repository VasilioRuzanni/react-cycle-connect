{"version":3,"file":"react-cycle-connect.umd.min.js","sources":["../../src/drivers/fnCallEffectDriver.ts","../../src/interactions/makeInteractFn.ts","../../src/interactions/makeInteractionsProp.ts","../../node_modules/@cycle/src/adapt.ts","../../src/interactions/DefaultInteractionsSource.ts","../../src/interactions/interactionsWrapper.ts","../../src/wrappers/reactLifecycleWrapper.ts","../../src/wrappers/reactPropsWrapper.ts","../../src/core/utils.ts","../../src/core/makeCycleNode.ts","../../src/cycleConnect.ts","../../src/components/Isolator.tsx"],"sourcesContent":["import { Stream } from 'xstream';\n\n// TODO: Somehow specify that this driver, while generic enough to operate\n// \"function calls\", not really that generic because function can be called\n// in a way that a synchronous response it expected (i.e., it might return\n// a `Promise` back, or just some pure calculation result).\n\n// TODO: Consider extending this to have result passed back as a source\n\nexport type FnCallEffect = {\n  fn: (...args: any[]) => any;\n  args: any[];\n};\n\nexport function makeFnCallEffectDriver() {\n  return function fnCallEffectDriver(fnCallEffect$: Stream<FnCallEffect>) {\n    fnCallEffect$.addListener({\n      next(fnCallEffect) {\n        if (typeof fnCallEffect.fn === 'function') {\n          fnCallEffect.fn.apply(null, fnCallEffect.args);\n        }\n      }\n    });\n  };\n}\n","import { Stream } from 'xstream';\nimport { InteractFn, InteractionEvent } from './types';\n\n// tslint:disable no-any\nexport function makeInteractFn(\n  interaction$: Stream<InteractionEvent>\n): InteractFn {\n  return function interactFn(interactionType: string, predefinedValue?: any) {\n    return (value: any) => {\n      interaction$._n({\n        type: interactionType,\n        value: typeof predefinedValue !== 'undefined' ? predefinedValue : value\n      });\n    };\n  };\n}\n","import { InteractFn, InteractionsProp } from './types';\n\n// tslint:disable no-any\nexport function makeInteractionsProp<TInteractionEvents = {}>(\n  interactFn: InteractFn\n): InteractionsProp<TInteractionEvents> {\n  const interactionsPropProxyHandler = {\n    get(target: any, interactionEventName: string) {\n      return interactFn.call(null, interactionEventName);\n    }\n  };\n\n  return new Proxy({}, interactionsPropProxyHandler);\n}\n",{"errno":-2,"code":"ENOENT","syscall":"open","path":"/Users/space/space/3_build/1_techniques/workshop/events/react-cycle-connect/node_modules/@cycle/src/adapt.ts"},"import { Stream, Subscription } from \"xstream\";\nimport { adapt } from \"@cycle/run/lib/adapt\";\nimport { InteractionsSourceInternal, InteractionEvent } from \"./types\";\n\nexport class DefaultInteractionsSource implements InteractionsSourceInternal {\n  _interaction$: Stream<InteractionEvent>;\n\n  constructor(stream: Stream<InteractionEvent>) {\n    this._interaction$ = adapt(stream);\n  }\n\n  // tslint:disable-next-line no-any\n  public select<TEvent = any, TInteractionType extends string = string>(\n    interactionSelector: TInteractionType\n  ): Stream<TEvent> {\n    return this._interaction$\n      .filter(\n        (i: InteractionEvent<TInteractionType>) =>\n          i.type === interactionSelector\n      )\n      .map(interaction => interaction.value);\n  }\n}\n\nexport default DefaultInteractionsSource;\n","import xs, { Stream, Subscription } from \"xstream\";\nimport dropRepeats from \"xstream/extra/dropRepeats\";\nimport sampleCombine from \"xstream/extra/sampleCombine\";\nimport { adapt } from \"@cycle/run/lib/adapt\";\nimport { Sources, Sinks, Drivers, Main } from \"@cycle/run\";\nimport { CycleMainFn } from \"../types\";\nimport { DefaultInteractionsSource } from \"./DefaultInteractionsSource\";\nimport {\n  InteractionsSourceInternal,\n  InteractionEvent,\n  InteractFn\n} from \"./types\";\nimport { makeInteractFn } from \"./makeInteractFn\";\nimport { ReactPropsSource } from \"../index\";\n\nexport function makeInteractionsWrapper() {\n  const name = \"interactions\";\n  const fnCallEffectDriverKey = \"fnCallEffect\"; // TODO: Make configurable\n\n  const interaction$ = xs.create<InteractionEvent>();\n  const interactFn = makeInteractFn(interaction$);\n\n  function interactionsWrapper(mainFn: CycleMainFn): CycleMainFn {\n    return function mainWithInteractions(\n      sources: Sources<Drivers>\n    ): Sinks<Main> {\n      const interactionsSource = new DefaultInteractionsSource(interaction$);\n      const interactionsSourceProxyHandler = {\n        // tslint:disable-next-line no-any\n        get(target: any, attr: string) {\n          if (typeof target[attr] === \"undefined\") {\n            return (target as InteractionsSourceInternal).select(attr);\n          }\n          return target[attr];\n        }\n      };\n\n      sources[name] = new Proxy(\n        interactionsSource,\n        interactionsSourceProxyHandler\n      );\n      const sinks = mainFn(sources);\n      const upstreamInteractions$ = sinks[name] as Stream<{\n        // tslint:disable-next-line no-any\n        [propName: string]: Stream<any>;\n      }>;\n\n      // TODO: The current experimental/hacky code should be removed, though\n      const propsSource = sources.props as ReactPropsSource<any>;\n      if (upstreamInteractions$ && propsSource) {\n        const props$ = propsSource.props$;\n        const upstreamInteractionFnCall$ = upstreamInteractions$\n          .compose(sampleCombine(props$))\n          .map(([upstreamInteractions, props]) => {\n            const fnCallStreams = Object.keys(upstreamInteractions)\n              .filter(propName => typeof props[propName] === \"function\")\n              .map(propName => {\n                return upstreamInteractions[propName].map(\n                  propInteractionValue => ({\n                    fn: props[propName],\n                    args: [propInteractionValue]\n                  })\n                );\n              });\n\n            return xs.merge.apply(null, fnCallStreams);\n          })\n          .flatten();\n\n        // TODO: We're mutating the sinks here, find out how to implement this\n        // in a more safe and elegant way\n        sinks[fnCallEffectDriverKey] = sinks[fnCallEffectDriverKey]\n          ? xs.merge(sinks[fnCallEffectDriverKey], upstreamInteractionFnCall$)\n          : upstreamInteractionFnCall$;\n      }\n\n      return sinks;\n    };\n  }\n\n  return {\n    interactionsWrapper,\n    interactFn\n  };\n}\n","import { ErrorInfo } from \"react\";\nimport xs, { Stream, MemoryStream } from \"xstream\";\nimport dropRepeats from \"xstream/extra/dropRepeats\";\nimport { adapt } from \"@cycle/run/lib/adapt\";\nimport { Sources, Sinks, Drivers, Main } from \"@cycle/run\";\nimport { CycleMainFn } from \"../types\";\n\nconst lifecycleHookNames = [\n  // \"willMount\",\n  \"didMount\",\n  // \"willReceiveProps\",\n  // \"willUpdate\",\n  \"didUpdate\",\n  \"willUnmount\",\n  \"didCatch\"\n];\n\nexport interface ReactLifecycleStreams<TProps> {\n  willMount$: Stream<null>;\n  didMount$: Stream<null>;\n  willReceiveProps$: Stream<TProps>;\n  willUpdate$: Stream<TProps>;\n  didUpdate$: Stream<TProps>;\n  willUnmount$: Stream<null>;\n  didCatch$: Stream<{\n    error: Error;\n    errorInfo: ErrorInfo;\n  }>;\n}\n\nexport class ReactLifecycleSource<TProps> {\n  lifecycleStreams: ReactLifecycleStreams<TProps>;\n\n  constructor(lifecycleStreams: ReactLifecycleStreams<TProps>) {\n    this.lifecycleStreams = lifecycleStreams;\n  }\n}\n\nlifecycleHookNames.forEach(hookName => {\n  ReactLifecycleSource.prototype[hookName] = function() {\n    return this.lifecycleStreams[`${hookName}$`];\n  };\n});\n\nexport function makeReactLifecycleWrapper<TProps>(): {\n  lifecycleWrapper: (mainFn: CycleMainFn) => CycleMainFn;\n  lifecycleStreams: ReactLifecycleStreams<TProps>;\n} {\n  const name = \"lifecycle\";\n\n  const lifecycleStreams = {} as ReactLifecycleStreams<TProps>;\n  lifecycleHookNames.forEach(hookName => {\n    lifecycleStreams[`${hookName}$`] = new Stream<any>();\n  });\n\n  function reactLifecycleWrapper(mainFn: CycleMainFn): CycleMainFn {\n    return function mainWithReactLifecycle(\n      sources: Sources<Drivers>\n    ): Sinks<Main> {\n      const _sources = {\n        ...sources,\n        [name]: new ReactLifecycleSource(lifecycleStreams)\n      };\n\n      return mainFn(_sources);\n    };\n  }\n\n  return {\n    lifecycleWrapper: reactLifecycleWrapper,\n    lifecycleStreams\n  };\n}\n","import xs, { Stream, MemoryStream, Subscription } from \"xstream\";\nimport dropRepeats from \"xstream/extra/dropRepeats\";\nimport { Sources, Sinks, Drivers, Main } from \"@cycle/run\";\nimport { adapt } from \"@cycle/run/lib/adapt\";\nimport { CycleMainFn } from \"../types\";\n\nexport class ReactPropsSource<TProps> {\n  public props$: MemoryStream<TProps>;\n  private _props$: MemoryStream<TProps>;\n\n  constructor(stream: Stream<TProps>) {\n    this._props$ = stream.compose(dropRepeats()).remember();\n    this.props$ = adapt(this._props$);\n  }\n\n  public pluck<P extends keyof TProps>(\n    propName: P\n  ): Stream<TProps[P] | undefined> {\n    return this._props$\n      .map(props => (props && props[propName]) || void 0)\n      .compose(dropRepeats())\n      .remember();\n  }\n\n  public select<P extends keyof TProps>(\n    propSelector: P\n  ): ReactPropsSource<TProps[P] | undefined> {\n    return new ReactPropsSource<TProps[P] | undefined>(\n      this.pluck(propSelector)\n    );\n  }\n}\n\nexport function makeReactPropsWrapper<TProps extends {}>(\n  inputProps$: Stream<TProps>,\n  willUnmount$: Stream<null>\n): {\n  propsWrapper: (main: CycleMainFn) => CycleMainFn;\n  props$: MemoryStream<TProps>;\n} {\n  const name = \"props\";\n  const props$ = xs.createWithMemory<TProps>().endWhen(willUnmount$);\n\n  function reactPropsWrapper(mainFn: CycleMainFn): CycleMainFn {\n    return function mainWithReactProps(sources: Sources<Drivers>): Sinks<Main> {\n      const sinkPropsImitator$ = xs.create<TProps>();\n      const combinedProps$ = xs\n        .merge(inputProps$, sinkPropsImitator$)\n        .fold<TProps>(\n          (combinedProps: TProps, newProps: TProps) => ({\n            ...(combinedProps as any),\n            ...(newProps as any)\n          }),\n          void 0 as any | undefined\n        )\n        .drop(1) // Dropping the initial `void 0`\n        .remember()\n        .endWhen(willUnmount$);\n\n      const _sources = {\n        ...sources,\n        [name]: new ReactPropsSource(combinedProps$) as any\n      };\n\n      const sinks = mainFn(_sources);\n      const propsSink = sinks[name];\n      delete sinks[name];\n\n      // Subscribe to combined props immediately to collect those in program's\n      // `propsSource` so that the first subscriber immediately gets its\n      // latest value.\n      combinedProps$.addListener({\n        next: (value: any) => props$._n(value)\n      });\n\n      if (propsSink) {\n        const sinkProps$ = xs.fromObservable(propsSink);\n\n        // TODO: Imitate with .imitate() once the way to convert\n        // `MemoryStream` to `Stream` is found\n        // sinkPropsImitator$.imitate(sinkProps$);\n        sinkProps$.endWhen(willUnmount$).addListener({\n          next: (value: any) => sinkPropsImitator$._n(value),\n          complete: () => sinkPropsImitator$._c(),\n          error: (error: any) => sinkPropsImitator$._e(error)\n        });\n      }\n\n      return sinks;\n    };\n  }\n\n  return {\n    propsWrapper: reactPropsWrapper,\n    props$\n  };\n}\n","import xs, { Stream, Subscription } from \"xstream\";\nimport { Drivers, Sources, Sinks, SinkProxies, Main } from \"@cycle/run\";\nimport isolate from \"@cycle/isolate\";\nimport {\n  CycleMainFn,\n  CycleMainFnWrapper,\n  CycleConnectOptionsProps,\n  IsolateOption\n} from \"../types\";\n\n// [[TODO: Think about renaming SinkProxies to something else maybe\n// to prevent confusing them with `@cycle/run`s SinkProxies type\n// and semantics of operating on the \"run\" side]]\n\n// Borrowed from `@cycle/run` itself (TODO: we might need a different type)\n// TODO: How to abstract away from `xs` here?\n// I mean, this is not really only internal stuff, its what drives\n// the app, so the actual streams should be a particular lib streams\n// (xstream, RxJS, most)\n// export function makeSinkProxies<\n//   So extends Sources<Drivers>,\n//   Si extends Sinks<Main>\n// >(driversOrSources: Drivers | So): SinkProxies<Si> {\n//   const sinkProxies: SinkProxies<Si> = {} as SinkProxies<Si>;\n//   // Note, that in both cases (drivers and sources) we need to preserve\n//   // all `sources`'  attributes, even if they're undefined, because there\n//   // might be write-only drivers that provide nothing as source, but still\n//   // expect something as sinks. So, if we filter them out as being \"falsy\"\n//   // and not create a sink proxy with that name, then we would never get\n//   // a value from a program to a write-only driver.\n//   for (const name in driversOrSources) {\n//     if (driversOrSources.hasOwnProperty(name)) {\n//       sinkProxies[name] = xs.create<any>();\n//     }\n//   }\n//   return sinkProxies;\n// }\n\nexport function makeSinkProxies(\n  driversOrSources: Drivers | Sources<Drivers>\n): SinkProxies<Drivers | Sources<Drivers>> {\n  const sinkProxies: SinkProxies<Drivers> = {} as SinkProxies<Drivers>;\n  for (const name in driversOrSources) {\n    if (driversOrSources.hasOwnProperty(name)) {\n      sinkProxies[name] = xs.create<any>();\n    }\n  }\n  return sinkProxies;\n}\n\nexport function subscribeStreamToStream(\n  stream: Stream<any>,\n  sourceStream: Stream<any>,\n  sourceName?: string\n): Subscription {\n  return sourceStream.subscribe({\n    next: (value: any) => stream._n(value),\n    error: (error: any) => stream._e(error),\n    // tslint:disable-next-line:no-empty\n    complete: () => {} // Noop\n  });\n}\n\nexport function subscribeSinkProxiesToSinks(\n  sinkProxies: SinkProxies<Drivers | Sources<Drivers>>,\n  sinks: Sinks<Main>\n): Subscription[] {\n  const sinkNames: Array<string> = Object.keys(sinks).filter(\n    name => !!sinkProxies[name]\n  );\n\n  return sinkNames.map(name =>\n    subscribeStreamToStream(\n      sinkProxies[name],\n      xs.fromObservable(sinks[name] as any),\n      name\n    )\n  );\n}\n\nexport function pipeWrapper(f: CycleMainFnWrapper, g: CycleMainFnWrapper) {\n  return (mainFn: CycleMainFn) => g(f(mainFn));\n}\n\nexport function wrapMain(\n  mainFn: CycleMainFn,\n  wrappers: CycleMainFnWrapper[] = []\n): CycleMainFn {\n  if (!wrappers.length) {\n    return mainFn;\n  }\n\n  const combinedWrapperFn = wrappers.reduce(pipeWrapper, (value: any) => value);\n  return combinedWrapperFn(mainFn);\n}\n\nexport function maybeIsolate<P extends CycleConnectOptionsProps>(\n  mainFn: CycleMainFn,\n  isolateOption?: IsolateOption,\n  isRootCycle?: boolean,\n  initialProps?: P\n): CycleMainFn {\n  // Rendering-level `isolate` prop, overrides component-level\n  // `isolate` option\n  const isolateProp =\n    initialProps && typeof initialProps.isolate !== \"undefined\"\n      ? initialProps.isolate\n      : void 0;\n\n  if (isolateProp) {\n    isolateOption = isolateProp;\n  }\n\n  // Do nothing unless there is `isolateOption` or `isolateProp`\n  if (!isolateOption) {\n    return mainFn;\n  }\n\n  const _isolateOption =\n    typeof isolateOption === \"function\"\n      ? isolateOption(initialProps)\n      : isolateOption;\n\n  return isolate(mainFn, _isolateOption);\n}\n","import { Stream, Subscription } from \"xstream\";\nimport {\n  Drivers,\n  Sources,\n  Sinks,\n  DisposeFunction,\n  SinkProxies,\n  Main\n} from \"@cycle/run\";\nimport isolate from \"@cycle/isolate\";\nimport { makeFnCallEffectDriver } from \"../drivers/fnCallEffectDriver\";\nimport {\n  CycleConnectOptions,\n  CycleConnectOptionsProps,\n  CycleMainFn,\n  CycleNode,\n  StatelessSinkProxies\n} from \"../types\";\nimport {\n  makeSinkProxies,\n  wrapMain,\n  maybeIsolate,\n  subscribeSinkProxiesToSinks\n} from \"./utils\";\n\nexport function makeCycleNode<P extends CycleConnectOptionsProps>(\n  mainFn: CycleMainFn,\n  cycleConnectOptions: CycleConnectOptions = {},\n  upstreamSources: Sources<Drivers> = {},\n  upstreamSinkProxies: SinkProxies<Sinks<Main>> = {},\n  initialProps?: P,\n  componentName?: string\n): CycleNode {\n  const isRootCycle = !!cycleConnectOptions.root;\n  const { drivers, isolate: isolateOption } = cycleConnectOptions;\n\n  const sinkProxies: StatelessSinkProxies<Sinks<Main>> =\n    isRootCycle && drivers ? makeSinkProxies(drivers) : {};\n  const childSources: Sources<Drivers> = {};\n  const sinkSubscriptions: Subscription[] = [];\n  const upstreamSinkSubscriptions: Subscription[] = [];\n  const innerSinks: Sinks<Main> = {};\n\n  function cycleNodeify(_mainFn: CycleMainFn): CycleMainFn {\n    return function mainCycleNodeified(sources: Sources<Drivers>) {\n      Object.assign(childSources, sources);\n      const _innerSinks = _mainFn(sources);\n\n      // Extend the sinkProxies with more stuff, possibly provided\n      // by the other wrappers (applied on top of this wrapper)\n      Object.assign(sinkProxies, makeSinkProxies(sources));\n      Object.assign(innerSinks, _innerSinks);\n\n      // Note: the actual subscription happens after we subscribed\n      // to upstream sinkProxies because the proxies are stateless\n      // and we want to make sure everything is wired up upfront\n      // (as long as its possible).\n      return sinkProxies;\n    };\n  }\n\n  // Note: The \"Cycle Node\" wrapper should go before regular wrappers\n  // so that children can see the possibly provided sources and return\n  // the sinks for these wrappers.\n  // \"Inner\" wrappers are applied first, though, as they're only working\n  // in the context of the \"current\" Cycle program.\n  // TODO: We're applying the wrappers here, but how'd we dispose\n  // them in case they need to? Or is it a particular wrapper responsibility\n  // to get connected to a pipeline in a way it automatically \"unsubscribes\"?\n  // Aside: Consider how this lays out into the upcoming Cycle plugins\n  // architecture.\n  const wrappers = [\n    ...(cycleConnectOptions._innerWrappers || []),\n    cycleNodeify,\n    ...(cycleConnectOptions.wrappers || [])\n  ];\n\n  const wrappedMain = wrapMain(mainFn, wrappers);\n  const wrappedAndIsolatedMain = maybeIsolate(\n    wrappedMain,\n    isolateOption,\n    isRootCycle,\n    initialProps\n  );\n\n  function _internalDispose() {\n    sinkSubscriptions.forEach(s => s.unsubscribe());\n    upstreamSinkSubscriptions.forEach(s => s.unsubscribe());\n    Object.keys(sinkProxies).forEach(name => sinkProxies[name]._c());\n  }\n\n  function subscribeToInnerSinks() {\n    Array.prototype.push.apply(\n      sinkSubscriptions,\n      subscribeSinkProxiesToSinks(sinkProxies, innerSinks)\n    );\n  }\n\n  return {\n    sinkProxies,\n    childSources,\n    run(): DisposeFunction {\n      if (isRootCycle) {\n        const runFn = cycleConnectOptions.runFn;\n        if (typeof runFn !== \"function\") {\n          throw new Error(\n            `You need the 'runFn' passed as configuration\n            option of cycleConnect(...) when 'root' option is enabled.`\n          );\n        }\n\n        const _drivers = {\n          // TODO: Make `fnCallEffect` key configurable\n          fnCallEffect: makeFnCallEffectDriver(),\n          ...cycleConnectOptions.drivers\n        };\n        const _cycleDispose = runFn(wrappedAndIsolatedMain, _drivers);\n        subscribeToInnerSinks();\n\n        return function disposeContext(): void {\n          _internalDispose();\n          _cycleDispose();\n        };\n      }\n\n      // Run the current \"sub-cycle\" otherwise\n      const _sinks = wrappedAndIsolatedMain(upstreamSources);\n      Array.prototype.push.apply(\n        upstreamSinkSubscriptions,\n        subscribeSinkProxiesToSinks(upstreamSinkProxies, _sinks)\n      );\n      subscribeToInnerSinks();\n\n      return function disposeContext(): void {\n        _internalDispose();\n      };\n    }\n  };\n}\n","import React, {\n  SFC,\n  PureComponent,\n  ComponentClass,\n  ComponentType,\n  ErrorInfo,\n  ReactNode\n} from \"react\";\nimport xs, { Stream, MemoryStream, Subscription } from \"xstream\";\nimport { Sources, Sinks, DisposeFunction, Drivers, Main } from \"@cycle/run\";\nimport isolate from \"@cycle/isolate\";\nimport { makeCycleNode } from \"./core/makeCycleNode\";\nimport { makeReactPropsWrapper } from \"./wrappers/reactPropsWrapper\";\nimport {\n  makeReactLifecycleWrapper,\n  ReactLifecycleStreams\n} from \"./wrappers/reactLifecycleWrapper\";\nimport {\n  makeInteractionsWrapper,\n  InteractFn,\n  InteractionsProp,\n  makeInteractionsProp,\n  InteractionsProps\n} from \"./interactions\";\nimport {\n  StatelessSinkProxies,\n  CycleConnectOptions,\n  CycleMainFn,\n  CycleMainFnWrapper,\n  CycleNode,\n  MakeConnectedComponentFn,\n  IsolateOption,\n  CycleConnectContextType,\n  ShouldUpdateFunction\n} from \"./types\";\n\nconst CONTEXT_TYPES = {\n  cycleNodeLink: () => null\n};\n\nfunction noopMainFn(sources: Sources<Drivers>): Sinks<Main> {\n  return {};\n}\n\nfunction defaultRenderFn(props: { children?: ReactNode }) {\n  return props.children || null;\n}\n\n// TODO: Reconsider typing (perhaps, once conditional types land in TypeScript)\nexport function cycleConnect<\n  TProps = {},\n  TViewProps = {},\n  TSinkProps = {},\n  TInteractionEvents = {}\n>(\n  mainFn: CycleMainFn<TProps | Partial<TViewProps>, TSinkProps>,\n  options?: CycleConnectOptions\n): MakeConnectedComponentFn<TProps, InteractionsProps>;\n\nexport function cycleConnect<TProps = {}>(\n  options: CycleConnectOptions\n): MakeConnectedComponentFn<TProps, InteractionsProps>;\n\nexport function cycleConnect<\n  TProps = {},\n  TViewProps = {},\n  TSinkProps = {},\n  TInteractionEvents = {}\n>(\n  mainFn:\n    | CycleMainFn<TProps | Partial<TViewProps>, TSinkProps>\n    | CycleConnectOptions,\n  options: CycleConnectOptions = {}\n): MakeConnectedComponentFn<TProps, InteractionsProps<TInteractionEvents>> {\n  let _mainFn: CycleMainFn;\n\n  if (typeof mainFn === \"object\") {\n    options = mainFn as CycleConnectOptions;\n    _mainFn = noopMainFn as CycleMainFn;\n  }\n\n  if (typeof mainFn === \"function\") {\n    _mainFn = mainFn;\n  }\n\n  return function makeComponent<TOuterProps, TInnerProps>(\n    WrappedComponent?: ComponentType<TInnerProps>\n  ) {\n    const sourceComponentName =\n      (options.render && \"customRenderFn\") ||\n      (WrappedComponent &&\n        (WrappedComponent.displayName ||\n          WrappedComponent.name ||\n          \"AnonymousComponent\")) ||\n      \"defaultRenderFn\";\n\n    const displayName =\n      options.displayName || `cycleConnect(${sourceComponentName})`;\n\n    const shouldUpdateFn = options.shouldUpdate || (x => true);\n\n    return class CycleConnectContainer extends PureComponent<TOuterProps> {\n      static contextTypes = CONTEXT_TYPES;\n      static childContextTypes = CONTEXT_TYPES;\n      static displayName = displayName;\n\n      cycleNode: CycleNode;\n      disposeCycleNode: DisposeFunction;\n\n      lifecycleStreams: ReactLifecycleStreams<TOuterProps>;\n\n      inputProps$: MemoryStream<TInnerProps>;\n      props$: MemoryStream<TInnerProps>;\n      props$Subscription: Subscription;\n      propsSnapshot: TInnerProps;\n\n      interactFn: InteractFn;\n      interactionsProp: InteractionsProp<TInteractionEvents>;\n\n      constructor(\n        props: TOuterProps & TInnerProps,\n        context: CycleConnectContextType\n      ) {\n        super(props, context);\n\n        const { cycleNodeLink } = context;\n        const sources = (cycleNodeLink && cycleNodeLink.sources) || {};\n        const sinkProxies = (cycleNodeLink && cycleNodeLink.sinkProxies) || {};\n\n        // Configuring internal wrappers\n        // React component lifecycle\n        const {\n          lifecycleWrapper,\n          lifecycleStreams\n        } = makeReactLifecycleWrapper<TOuterProps>();\n        this.lifecycleStreams = lifecycleStreams;\n\n        // React props\n        this.inputProps$ = xs.createWithMemory<TInnerProps>().startWith(props);\n        const { propsWrapper, props$ } = makeReactPropsWrapper(\n          this.inputProps$,\n          this.lifecycleStreams.willUnmount$\n        );\n        this.props$ = props$;\n\n        // Interactions\n        const { interactionsWrapper, interactFn } = makeInteractionsWrapper();\n        this.interactFn = interactFn;\n        this.interactionsProp = makeInteractionsProp(interactFn);\n\n        const _options = {\n          ...options,\n          _innerWrappers: [interactionsWrapper, propsWrapper, lifecycleWrapper]\n        };\n\n        this.cycleNode = makeCycleNode(\n          _mainFn,\n          _options,\n          sources,\n          sinkProxies,\n          props,\n          displayName\n        );\n\n        this.disposeCycleNode = this.cycleNode.run();\n      }\n\n      getChildContext(): CycleConnectContextType {\n        const cn = this.cycleNode;\n        if (!cn) {\n          return {};\n        }\n\n        return {\n          cycleNodeLink: {\n            sources: cn.childSources,\n            sinkProxies: cn.sinkProxies\n          }\n        };\n      }\n\n      // componentWillMount() {\n      //   this.subscribeToPropsUpdates();\n      //   this.lifecycleStreams.willMount$._n(null);\n      // }\n\n      componentDidMount() {\n        //   this.lifecycleStreams.willMount$._n(null);\n        this.subscribeToPropsUpdates(shouldUpdateFn);\n        this.lifecycleStreams.didMount$._n(null);\n      }\n\n      // componentWillReceiveProps(nextProps: Readonly<TOuterProps>) {\n      //   this.lifecycleStreams.willReceiveProps$._n(nextProps);\n      // }\n\n      // NOTE: Not passing `nextState` intentionally, keep the state\n      // inside the \"connected\" Cycle program instead.\n      // componentWillUpdate(nextProps: Readonly<TOuterProps>) {\n      //   this.lifecycleStreams.willUpdate$._n(nextProps);\n      // }\n\n      componentDidUpdate(prevProps: Readonly<TOuterProps>) {\n        this.lifecycleStreams.didUpdate$._n(prevProps);\n      }\n\n      componentWillUnmount() {\n        this.lifecycleStreams.willUnmount$._n(null);\n\n        if (this.disposeCycleNode) {\n          this.disposeCycleNode();\n        }\n      }\n\n      componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n        this.lifecycleStreams.didCatch$._n({ error, errorInfo });\n      }\n\n      subscribeToPropsUpdates(shouldUpdateFn: ShouldUpdateFunction) {\n        this.props$.endWhen(this.lifecycleStreams.willUnmount$).addListener({\n          next: (props: TInnerProps) => {\n            const update = shouldUpdateFn(this.propsSnapshot, props);\n            this.propsSnapshot = props;\n            update && this.forceUpdate();\n          }\n        });\n      }\n\n      render() {\n        const props = {\n          ...(this.propsSnapshot as any),\n          interact: this.interactFn,\n          interactions: this.interactionsProp\n        };\n\n        if (typeof options.render === \"function\") {\n          return options.render(props);\n        }\n\n        return WrappedComponent\n          ? React.createElement(WrappedComponent, props)\n          : defaultRenderFn(props);\n      }\n    };\n  };\n}\n","import React, { ReactNode } from 'react';\nimport { Scopes } from '@cycle/isolate';\nimport { cycleConnect } from '../cycleConnect';\n\nexport interface Props {\n  children: ReactNode;\n  scope: Scopes<any>;\n}\n\nexport const Isolator = cycleConnect<Props>({\n  isolate: (props: Props) => props.scope || void 0,\n  displayName: 'Isolator'\n})();\n\nexport default Isolator;\n"],"names":["makeFnCallEffectDriver","fnCallEffect$","addListener","next","fnCallEffect","fn","apply","args","makeInteractFn","interaction$","interactionType","predefinedValue","value","_n","type","makeInteractionsProp","interactFn","Proxy","get","target","interactionEventName","call","getGlobal","globalObj","window","global","this","Cyclejs","adaptStream","x","exports","f","stream","_interaction$","adapt","DefaultInteractionsSource","interactionSelector","filter","i","map","interaction","makeInteractionsWrapper","name","fnCallEffectDriverKey","xs","create","interactionsWrapper","mainFn","sources","interactionsSource","attr","select","sinks","upstreamInteractions$","propsSource","props","props$","upstreamInteractionFnCall$","compose","sampleCombine","_a","upstreamInteractions","fnCallStreams","Object","keys","propName","propInteractionValue","merge","flatten","lifecycleHookNames","lifecycleStreams","makeReactLifecycleWrapper","forEach","hookName","Stream","lifecycleWrapper","_sources","ReactLifecycleSource","prototype","_props$","dropRepeats","remember","ReactPropsSource","propSelector","pluck","makeReactPropsWrapper","inputProps$","willUnmount$","createWithMemory","endWhen","propsWrapper","sinkPropsImitator$","combinedProps$","fold","combinedProps","newProps","drop","propsSink","fromObservable","complete","_c","error","_e","makeSinkProxies","driversOrSources","sinkProxies","name_1","hasOwnProperty","subscribeSinkProxiesToSinks","subscribe","pipeWrapper","g","makeCycleNode","cycleConnectOptions","upstreamSources","upstreamSinkProxies","initialProps","componentName","isRootCycle","root","drivers","isolateOption","childSources","sinkSubscriptions","upstreamSinkSubscriptions","innerSinks","wrappedAndIsolatedMain","isolateProp","isolate","_isolateOption","maybeIsolate","wrappers","length","reduce","combinedWrapperFn","wrapMain","_innerWrappers","_mainFn","assign","_innerSinks","_internalDispose","s","unsubscribe","subscribeToInnerSinks","Array","push","run","runFn","Error","_drivers","_cycleDispose_1","_sinks","CONTEXT_TYPES","cycleNodeLink","noopMainFn","cycleConnect","options","WrappedComponent","sourceComponentName","render","displayName","shouldUpdateFn","shouldUpdate","context","_super","_this","startWith","_b","interactionsProp","_options","cycleNode","disposeCycleNode","__extends","CycleConnectContainer","cn","subscribeToPropsUpdates","didMount$","prevProps","didUpdate$","errorInfo","didCatch$","update","propsSnapshot","forceUpdate","interact","interactions","React","createElement","children","defaultRenderFn","PureComponent","Isolator","scope"],"mappings":"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"}